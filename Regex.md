# Regex

##  шаблоны и флаги

``` regexp = new RegExpt("шаблон", "флаги");```

коротки синтаксис

``` 
regexp = /шаблон/; // без флага
regexpt = /шаблон/gmi; // с флагами gmi

new RegExp - регулярка из динамической сгенерированной строки
```

### Флаги

- ``` i ``` - поиск не зависит от регистра
- ``` g ``` - ищет все сопадения, без него - только первое 
- ``` m ``` - многостроочный режим
- ``` s ``` - включает режим "dotall" при котором точка ``` . ``` может соответствовать символу переводу строки как ``` \n ``` 
- ``` u ``` - включает полную поддержку Юникода. Флаг разрешает корректную обработку суррогатных пар
- ``` y ``` - режим поиска на конкретной позиции в тексте

### Поиск: str.match

``` str.match(regexp) ``` 
Есть три режима работы:
1. Если у рег выражения есть флаг ```g```, то он возвращает массив совпадений
```
let str = "Love, apple, love";

alert( str.match(/love/gi) ); // Love, lova (array);
```

2. Если такого флага нет, то возвращается только первое совпадние в виде массива. С самим элементов и доп. информацией о нём
```
let str = "Love, apple, love";
let res = str.match(/love/i);

alert(res[0]); // Love (first word);
alert(res.length); // 1

alert(res.index); // 0 (index of finded work)
alert(res.input); // Love, apple, lova (all string)
```
3. Если совпадений нет, то, вне зависимости от наличия флага ```g``` возвращает null
```
let matches = "Javascript".match(/HTML/); // = null

if(!matches.length) { // error: null hasn't property length
  alert("Error");
}
```

```
let matches = "Javascript".match(/HTML/) || [];

if(!matches.length) {
  alert("Mateches not founed"); 
}
```

### Замена: str.replace

```str.replace(regexp, replacement)``` заменяет совпадения с ```regexp``` в строке ```str``` на ```replacement```

```
// without flag g
alert("We will, we will".replace(/we/i, "I")); // I will, we will

// witch flag g
alert("We will, we will".replace(/we/ig", "I")); // I will, I will
```

Так же в ```replacement``` можно использовать специальные компинации символов

- $& - вставляет все найденное совпадение
- $` - вставляет часть строки до совпадения
- $' - вставляет часть строки после совпадения
- $n -  если ```n``` это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения
- $<name> - вставляет содержимое скобочной группы с именем ```name```
- $$ - вставляет символ "$" 

```
alert ("Love html".replace(/HTML/, "$& and Javascript)); // "Love html and Javascript"
```
  
## Символьные классы
  
  - ```\d``` - (digit:цифра) класс цифры, соотвествует любой одной цифре
  - ```\s``` - (space:пробел) включают в себя табуляцию ```/t```, перевод строки ```/n```,  и другие ```/v```, ```/f```, ```/r```
  - ```\w``` - (word:слово) любая буква, символ, цифра или подчеркивание, только латинский алфавит

  Например ```\d\s\w``` означает цифру, за которой идет пробельный символ, а затем символ слова - ```1 a```
  
  ```
  let str = "Есть ли стандарт CSS4?";
  let regexp = /CSS\d/

  alert( str.match(regexp) ); // CSS4
  ```
  
  ``` alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'```

  ### Обратный символный класс 
  
  Для каждого символьного класса существует обратный символьный класс, обозначаемый той же буквой, но в верхнем регистре. ```\D``` ```\S``` ```\W``` обозначают все символы кроме указанного, например, ```\S``` - любой символ кроме ```\s```, буква или цифра
  
  ### Точка это любой символ
  
  Точка ```.``` – это специальный символьный класс, который соответствует «любому символу, кроме новой строки».
  
  ```alert("qwerty".match(/./)) // qwerty```
  
  ```
  let regexp = /CS.4/;

  alert( "CSS4".match(regexp) ); // CSS4
  alert( "CS-4".match(regexp) ); // CS-4
  alert( "CS 4".match(regexp) ); // CS 4 (пробел тоже является символом)
  ```
  
  Обычно точке не соответствует перевод строки ```\n```, но если это нужно, чтобы точка соотвестовала действительно всему то нужен флаг ```s```
  
  ```
  alert( "A\nB".match(/A.B/s) ); // A\nB (совпадение!)
  ```
  
  ## Юникод: флаг "u" и класс \p{...}
  
  Класс ```\p``` работает с флагом ```u```
  
  ```
  let str = "A ბ ㄱ";
  
  alert( str.match(/\p{L}/gu) ); // A,ბ,ㄱ
  alert( str.match(/\p{L}/g) ); // null (ничего не нашло, так как \p не работает без флага "u")
  ```

  
  Вот основные категории символов и их подкатегории:

- Буквы L:
  - в нижнем регистре Ll,
  - модификаторы Lm,
  - заглавные буквы Lt,
  - в верхнем регистре Lu,
  - прочие Lo.
- Числа N:
  - десятичная цифра Nd,
  - цифры обозначаемые буквами (римские) Nl,
  - прочие No.
- Знаки пунктуации P:
  - соединители Pc,
  - тире Pd,
  - открывающие кавычки Pi,
  - закрывающие кавычки Pf,
  - открывающие скобки Ps,
  - закрывающие скобки Pe,
  - прочее Po.
- Отметки M (например, акценты):
  - двоеточия Mc,
  - вложения Me,
  - апострофы Mn.
- Символы S:
  - валюты Sc,
  - модификаторы Sk,
  - математические Sm,
  - прочие So.
- Разделители Z:
  - линия Zl,
  - параграф Zp,
  - пробел Zs.
- Прочие C:
  - контрольные Cc,
  - форматирование Cf,
  - не назначенные Cn,
  - для приватного использования Co,
  - суррогаты Cs.

Так что, например, если нам нужны буквы в нижнем регистре, то можно написать \p{Ll}, знаки пунктуации: \p{P} и так далее.

Есть и другие категории – производные, например:

- Alphabetic (Alpha), включающая в себя буквы L, плюс «буквенные цифры» Nl (например Ⅻ – символ для римской записи числа 12), и некоторые другие символы - Other_Alphabetic (OAlpha).
- Hex_Digit включает символы для шестнадцатеричных чисел: 0-9, a-f.

Юникод поддерживает много различных свойств, их полное перечисление потребовало бы очень много места, поэтому вот ссылки:

- По символу посмотреть его свойства: https://unicode.org/cldr/utility/character.jsp.
- По свойству посмотреть символы с ним: https://unicode.org/cldr/utility/list-unicodeset.jsp.
- Короткие псевдонимы для свойств: https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt.
- Полная база Юникод-символов в текстовом формате вместе со всеми свойствами, находится здесь: https://www.unicode.org/Public/UCD/latest/ucd/.

## Якоря: начало строки ^ и конец $
  
  Каретка ```^``` означает совпадение с началом текста, а доллар ```$``` – с концом.

  К примеру, давайте проверим начинается ли текст с ```Mary```:
  ```
  let strYak1 = "Mary had a little lamb";
console.log(/^Mary/.test(strYak1));
  ``` 
  Аналогичное и с ```$``` только конец строки.
  
  Оба якоря вместе ```^...$``` часто используются для проверки, совпадает ли строка с шаблоном полностью. Например, чтобы определить, в правильном ли формате пользователь ввёл данные.
  
  ## Многострочный режим якорей ^ $, флаг "m"

  В многострочном режиме они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.
  
  Поиск в начале строки ^
В примере ниже текст состоит из нескольких строк. Шаблон ```/^\d/gm``` берёт цифру с начала каждой строки:
```
let str = `1е место: Винни
2е место: Пятачок
3е место: Слонопотам`;

console.log( str.match(/^\d/gm) ); // 1, 2, 3
```
  
  ## Граница слова: \b
  
  Граница слова \b – проверка, как ^ и $.

Когда движок регулярных выражений (программный модуль, реализующий поиск по регулярным выражениям) видит \b, он проверяет, что позиция в строке является границей слова.

Есть три вида позиций, которые являются границами слова:

- Начало текста, если его первый символ ```\w```.
- Позиция внутри текста, если слева находится ```\w```, а справа – не ```\w```, или наоборот.
- Конец текста, если его последний символ ```\w```.
Например, регулярное выражение ```\bJava\b``` будет найдено в строке ``Hello, Java!```, где ```Java``` – отдельное слово, но не будет найдено в строке ```Hello, JavaScript!```.
```
alert( "Hello, Java!".match(/\bJava\b/) ); // Java
alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null
```  
  
```
let strTime2 = "Завтрак в 11:00 в комнате 123:456.";
console.log(strTime2.match(/\b\d\d:\d\d\b/g));
```
  
 ## Экранирование, специальные символы
  
  Допустим, мы хотим найти буквально точку. Не «любой символ», а именно точку.

Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: ```\.```.
  ```
  alert( "Глава 5.1".match(/\d\.\d/) ); // 5.1 (совпадение!)
alert( "Глава 511".match(/\d\.\d/) ); // null ("\." - ищет обычную точку)
  ```
  ```
  alert( "/".match(/\//) ); // '/'
  ```
  ### new RegExp
  
  ```
  alert("\d\.\d"); // d.d
  
  let regexp = new RegExp("\d\.\d");

alert( "Глава 5.1".match(regexp) ); // null
  ```
  
  ```
  let regStr = "\\d\\.\\d";
alert(regStr); // \d\.\d (теперь правильно)

let regexp = new RegExp(regStr);

alert( "Глава 5.1".match(regexp) ); // 5.1
  ```
  
  Ковычки "съедают" косую черту, но в new RegExp слеш ```/``` экранировать не надо
  
  ## Наборы и диапазоны [...]
  Несколько символов или символьных классов в квадратных скобках […] означают «искать любой символ из заданных».
  
  ```
  // найти [т или х], после которых идёт "оп"
  alert( "Топ хоп".match(/[тх]оп/gi) ); // "Топ", "хоп"
  ```
  
  ### Диапазоны
  
  ```[a-z]``` соответствует символу в диапазоне от ```a``` до ```z```, или ```[0-5]``` – цифра от ```0``` до ```5```.
  
Ищет ```x``` за которой следуют две цифры или буквы от ```A``` до ```F```.
  ```
  alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF

  ```
  
  Символьные классы – сокращения для наборов символов
  
 ### Пример: многоязычный аналог \w
  
- Alphabetic (Alpha) – для букв,
- Mark (M) – для акцентов,
- Decimal_Number (Nd) – для цифр,
- Connector_Punctuation (Pc) – для символа подчёркивания '_' и подобных ему,
- Join_Control (Join_C) – два специальных кода 200c и 200d, используемые в лигатурах, например, арабских.

  Пример использования:
```
let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;

let str = `Hi 你好 12`;

// найдены все буквы и цифры
alert( str.match(regexp) ); // H,i,你,好,1,2
```
  
  ### Исключающие диапазоны
  Помимо обычных диапазонов, есть «исключающие» диапазоны, которые выглядят как ```[^…]```.

Они обозначаются символом каретки ```^``` в начале диапазона и соответствуют любому символу за исключением заданных.
  
  Например:

- ```[^aeyo]``` – любой символ, за исключением ```'a'```, ```'e'```, ```'y'``` или ```'o'```.
- ```[^0-9]``` – любой символ, за исключением цифры, то же, что и ```\D```.
- ```[^\s]``` – любой непробельный символ, то же, что и ```\S```.
  
```
alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ и .
```

### Экранирование внутри […]

не нужно

## Квантификаторы +, *, ? и {n}

### Количество {n}

Самый простой квантификатор — это число в фигурных скобках: ```{n}```.

Он добавляется к символу (или символьному классу, или набору ```[...]``` и т.д.) и указывает, сколько их нам нужно.

Шаблон ```\d{5}``` обозначает ровно 5 цифр, он эквивалентен ```\d\d\d\d\d```.

Диапазон: ```{3,5}```, от ```3``` до ```5```
Для того, чтобы найти числа от ```3``` до ```5``` цифр, мы можем указать границы в фигурных скобках: ```\d{3,5}```
  
```
  let str = "+7(903)-123-45-67";

let numbers = str.match(/\d{1,}/g);

alert(numbers); // 7,903,123,45,67
  ```
  
### Короткие обозначения
  
```+``` Означает «один или более». То же самое, что и ```{1,}```.
  
  
```
let str = "+7(903)-123-45-67";

alert( str.match(/\d+/g) ); // 7,903,123,45,67
```
  
  ```?```
Означает «ноль или один». То же самое, что и ```{0,1}```. По сути, делает символ необязательным.
  
  ```*```
Означает «ноль или более». То же самое, что и ```{0,}```. То есть символ может повторяться много раз или вообще отсутствовать.
  
  
  
## Жадные и ленивые квантификаторы
  
### Жадный поиск
  
Чтобы найти совпадение, движок регулярных выражений работает по следующему алгоритму:

- Для каждой позиции в строке для поиска:
- Попробовать найти совпадение с шаблоном на этой позиции.
- Если нет совпадения, переход к следующей позиции.
  
### Ленивый режим
  
«Ленивый» режим противоположен «жадному». Он означает: «повторять квантификатор наименьшее количество раз».

Мы можем включить его, вставив знак вопроса ```'?'``` после квантификатора, то есть будет ```*?``` или ```+?``` или даже ```??``` для ```'?'```.
  
Проясним: обычно знак вопроса ```?``` сам по себе является квантификатором (ноль или один), но, если он добавлен после другого квантификатора (или даже после самого себя), он получает другое значение – он меняет режим совпадения с жадного на ленивый.

Регулярное выражение ```/".+?"/g``` работает как задумано, оно находит ```"witch"``` и ```"broom"```:
  
```
alert( "123 456".match(/\d+ \d+?/) ); // 123 4
```

1. Шаблон ```\d+``` пытается найти столько цифр, сколько возможно (жадный режим), так что он находит ```123``` и останавливается, потому что следующим символом будет пробел ```' '```.

2. Дальше в шаблоне пробел и в строке тоже, так что есть совпадение.

3. Затем идёт ```\d+?```. Квантификатор находится в ленивом режиме, так что он находит одну цифру ```4``` и проверяет, есть ли совпадение для оставшегося шаблона с этого места.

…Но в шаблоне ```\d+?``` больше ничего нет.

Ленивый режим ничего не повторяет без необходимости. Шаблон закончился, заканчивается и поиск. Мы получаем ```123 4```.
  
Альтернатива - ```"[^"]+":```
  
  
```
let str1 = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let str2 = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let regexp = /<a href="[^"]*" class="doc">/g;

// Работает!
alert( str1.match(regexp) ); // совпадений нет, всё правильно
alert( str2.match(regexp) ); // <a href="link1" class="doc">, <a href="link2" class="doc">
```
  
## Скобочные группы
  
Часть шаблона можно заключить в скобки ```(...)```. Это называется «скобочная группа».

У такого выделения есть два эффекта:

Позволяет поместить часть совпадения в отдельный массив.
Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу
  
### Пример: gogogo
Без скобок шаблон ```go+``` означает символ g и идущий после него символ o, который повторяется один или более раз. Например, ```goooo``` или ```gooooooooo```.

Скобки группируют символы вместе. Так что ```(go)+``` означает ```go```, ```gogo```, ```gogogo``` и т.п.
  
## Пример: домен

## Пример: email

```  
let str9 = "my@mail.com sdf 2 sdf@ sdf;ksdf.sdf";

// let str9a = str9.match(/[-.\w]+@\w+.\w+/gi);
let str9a = str9.match(/[-.\w]+@([\w-]+\.)+[\w-]+/g);
```
  
Метод str.match(regexp), если у регулярного выражения regexp нет флага g, ищет первое совпадение и возвращает его в виде массива:

1. На позиции 0 будет всё совпадение целиком.
2. На позиции 1 – содержимое первой скобочной группы.
3. На позиции 2 – содержимое второй скобочной группы.
…и так далее…
  
