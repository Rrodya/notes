

# Pinia

## Определение

Pinia начиналась как исследование того, как может выглядеть следующая итерация Vuex, включающая в себя многие идеи из обсуждений основной команды для Vuex 5. В конце концов, мы поняли, что Pinia уже реализует большую часть того, что мы хотели, в Vuex 5, и решили сделать это. вместо этого новая рекомендация.

По сравнению с Vuex, Pinia предоставляет более простой API с меньшими церемониями, предлагает API-интерфейсы в стиле Composition-API и, что наиболее важно, имеет надежную поддержку вывода типов при использовании с TypeScript.

API Pinia сильно отличается от Vuex ≤4, а именно:

мутаций больше нет. Они часто воспринимались как чрезвычайно многословные. Сначала они привнесли интеграцию с devtools, но это уже не проблема.
Нет необходимости создавать собственные сложные оболочки для поддержки TypeScript, все типизировано, а API разработан таким образом, чтобы максимально использовать вывод типа TS.
Не нужно динамически добавлять хранилища, они все динамические по умолчанию. Обратите внимание, что вы по-прежнему можете вручную использовать хранилище для его регистрации в любое время, но, поскольку это происходит автоматически, вам не нужно об этом беспокоиться.
Нет больше вложенного структурирования модулей. Вы по-прежнему можете неявно вкладывать хранилища, импортируя и используя хранилище внутри другого, но Pinia предлагает плоскую структуру по дизайну, в то же время предоставляя способы перекрестной композиции между хранилищами. Вы даже можете иметь циклические зависимости магазинов.
Нет модулей с пространством имен. Учитывая плоскую архитектуру хранилищ, хранилища с «пространством имен» присущи тому, как они определены, и можно сказать, что все хранилища имеют пространство имен.

## Создание

Pinia - библиотека для работы с глобальным стейтом

Параллельно с разработкой 5-й версии Vuex, создавалась Pinia. Из-за некоторых архитектурных решений pinia стало предлогаться как рекомендуемая библиотека для глобального хранилища

## Основные отличие Pinia от Vuex

1. Работает на основе моделей, легче обращаться из компонентов, можно вызывать один модуль из другого
2. Отсутсвует мутации, во vuex для синхронных операция (изменения переменных в стейте) если обратиться к серверу то имспользовали actions. В Pinia для все операция используем actions
3. Из коробки отличная поддержка TypeScript
4. Можно использовать синтаксис, окторый очень похож на Composition API

## main.ts Инициализация pinia

## Defining

### optionStore

- difining/option.md

Нам нужно знать, что хранилище определяется с помощью defineStore() и что для него требуется уникальное имя, передаваемое в качестве первого аргумента:

Это имя, идентификатор, необходимо и используется Pinia для подключения хранилища к devtools. Именование возвращаемой функции use

defineStore() принимает два разных значения в качестве второго аргумента: функцию Setup или объект Options.

Подобно Options Api Vue, мы также можем передать объект параметров со свойствами состояния, действий и геттеров.

### setupStore

- difining/setup.md


Существует также другой возможный синтаксис для определения хранилищ. Подобно функции настройки Vue Composition API, мы можем передать функцию, которая определяет реактивные свойства и методы и возвращает объект со свойствами и методами, которые мы хотим предоставить.

## Store

- store.ts

В Pinia состояние определяется как функция, возвращающая начальное состояние. Это позволяет Pinia работать как на стороне сервера, так и на стороне клиента.


### Typescripot
- userStore.ts

Если хотите, вы можете определить состояние с помощью интерфейса и ввести возвращаемое значение state():
- userStoreTs.ts

By default, you can directly read and write to the state by accessing it through the store instance:

```const store = useStore()```

store.count++
Note you cannot add a new state property if you don't define it in state(), it must contain the initial state. e.g.: we can't do store.secondCount = 2 if secondCount is not defined in state().

### ```$patch()```

Основное отличие состоит в том, что $patch() позволяет сгруппировать несколько изменений в одну запись в devtools. Обратите внимание, что прямые изменения состояния и $patch() появляются в инструментах разработки и могут перемещаться во времени (еще не во Vue 3).

Вы можете наблюдать за состоянием и его изменениями через метод хранилища $subscribe(), аналогичный методу подписки Vuex.

## Getters

- getters/counterStore.ts

Геттеры в точности эквивалентны вычисляемым значениям состояния хранилища. Их можно определить с помощью свойства getters в defineStore(). Они получают `state` в качестве первого параметра:


В большинстве случаев геттеры будут полагаться только на состояние, однако им может понадобиться использовать другие геттеры. Из-за этого мы можем получить доступ ко всему экземпляру хранилища через this при определении обычной функции, но необходимо определить тип возвращаемого типа (в TypeScript). Это связано с известным ограничением в TypeScript и не влияет на геттеры, определенные с помощью функции стрелки, а также на геттеры, не использующие это:

- getters/getters.md




## Actions

Как и геттеры, actions получают доступ ко всему экземпляру хранилища через ```this``` . В отличие от геттеров, действия могут быть асинхронными

Чтобы использовать хранилище, можно использовать его непосредственно внутри action:

`Подписка на actions`

Acitons вызываются как методы

Чтобы использовать другое хранилище, можно использовать его непосредственно внутри action:

За действиями и их результатом можно наблюдать с помощью `store.$onAction()`. Переданный ему обратный вызов выполняется до самого действия. Аналогичным образом onError позволяет вам выполнять функцию, если действие выдает или отклоняет. Они полезны для отслеживания ошибок во время выполнения, подобно этому совету в документации Vue.

Вот пример, который регистрируется перед выполнением действий и после их разрешения/отклонения.

По умолчанию подписки на действия привязаны к компоненту, в который они добавляются (если хранилище находится внутри компонента setup()). Это означает, что они будут автоматически удалены при размонтировании компонента. Если вы также хотите сохранить их после размонтирования компонента, передайте true в качестве второго аргумента, чтобы отсоединить подписку на действие от текущего компонента:

## Plugins

Хранилища Pinia могут быть полностью расширены благодаря низкоуровневому API. Вот список вещей, которые можно сделать:

- Добавляйте новые свойства в хранилища
- Добавить новые параметры при определении хранилища
- Добавляйте новые методы в магазины
- Оберните существующие методы
- Изменить или даже отменить действия
- Реализовать побочные эффекты, такие как локальное хранилище
- Применять только к определенным магазинам

Плагины добавляются к экземпляру pinia с помощью pinia.use(). Самый простой пример — добавление статического свойства во все хранилища путем возврата объекта:

Плагин Pinia — это функция, которая при необходимости возвращает свойства для добавления в хранилище. Он принимает один необязательный аргумент, контекст:

Любое свойство, возвращаемое плагином, будет автоматически отслеживаться devtools, поэтому, чтобы сделать hello видимым в devtools, обязательно добавьте его в store._customProperties в режиме разработки, только если вы хотите отлаживать его в devtools:

## Миграция 

Vuex имеет концепцию единого хранилища с несколькими модулями. Эти модули могут быть опционально объединены в пространство имен и даже вложены друг в друга.

Самый простой способ перенести эту концепцию на использование с Pinia заключается в том, что каждый модуль, который вы использовали ранее, теперь является хранилищем. Для каждого хранилища требуется идентификатор, аналогичный пространству имен в Vuex. Это означает, что каждое хранилище имеет пространство имен по дизайну. Вложенные модули также могут стать собственным хранилищем. Stores, которые зависят друг от друга, просто импортируют другой store.

- migration/structure.md

Это создает плоскую структуру для хранилищ, но также сохраняет предыдущее пространство имен с эквивалентными идентификаторами. Если у вас есть какие-то состояния/геттеры/действия/мутации в корне хранилища (в файле store/index.js Vuex), вы можете создать другое хранилище с именем что-то вроде root, которое содержит всю эту информацию.

Каталог для Pinia обычно называется store, а не store. Это сделано для того, чтобы подчеркнуть, что Pinia использует несколько хранилищ вместо одного в Vuex.

Для больших проектов вы можете выполнять это преобразование модуль за модулем, а не преобразовывать все сразу. На самом деле вы можете смешивать Pinia и Vuex вместе во время миграции, поэтому этот подход также может работать, и это еще одна причина вместо этого называть хранилища каталогов Pinia.

Вот полный пример до и после преобразования модуля Vuex в хранилище Pinia, см. ниже пошаговое руководство. В примере Pinia используется хранилище опций, так как структура больше всего похожа на Vuex:

- migration/singleModule.md

1. Add a required ```id``` for the store, you may wish to keep this the same as the namespace before. It is also recommended to make sure the ```id``` is in camelCase as it makes it easier to use with ```mapStores()```.
2. Convert ```state``` to a function if it was not one already
3. Convert ```getters```
  - Remove any getters that return state under the same name (eg. ```firstName: (state) => state.firstName)```, these are not necessary as you can access any state directly from the store instance
  -  If you need to access other getters, they are on ```this``` instead of using the second argument. Remember that if you are using ```this``` then you will have to use a regular function instead of an arrow function. Also note that you will need to specify a return type because of TS limitations, see here for more details
  -  If using ```rootState``` or ```rootGetters``` arguments, replace them by importing the other store directly, or if they still exist in Vuex then access them directly from Vuex
4. Convert ```actions```
  -  Remove the first ```context``` argument from each action. Everything should be accessible from ```this``` instead
  -  If using other stores either import them directly or access them on Vuex, the same as for getters
5. Convert ```mutations```
  -  Mutations do not exist any more. These can be converted to ```actions``` instead, or you can just assign directly to the store within your components (eg. ```userStore.firstName = 'First'```)
  -  If converting to actions, remove the first ```state``` argument and replace any assignments with ```this``` instead
  -  A common mutation is to reset the state back to its initial state. This is built in functionality with the store's ```$reset``` method. Note that this functionality only exists for option stores.

- migration/usage.md

Теперь, когда ваш модуль Vuex преобразован в хранилище Pinia, любой компонент или другой файл, который использует этот модуль, также необходимо обновить.

Если вы раньше использовали хелперы map из Vuex, стоит посмотреть руководство по использованию без setup(), так как большинство этих хелперов можно использовать повторно.

Если вы использовали useStore, вместо этого импортируйте новое хранилище напрямую и получите доступ к его состоянию. Например:

- migration/usageOuside.md


Обновление использования вне компонентов должно быть простым, если вы следите за тем, чтобы не использовать хранилище вне функций. Вот пример использования хранилища в навигационной защите Vue Router:







